#!/usr/bin/expect -f
#
# End-to-End Integration Test for testcase-manager CLI
#
# This test script automates the complete workflow of the testcase-manager tool,
# including metadata creation, initial conditions, device selections, test sequences,
# and steps. It validates the output YAML file structure and verifies that git commits
# are created at appropriate checkpoints.
#
# Usage: ./tests/integration/e2e_complete_workflow.exp [binary_path]
#

# Configure expect behavior
set timeout 60
log_user 1

# Get binary path from argument or use default
if {$argc > 0} {
    set binary_path [lindex $argv 0]
} else {
    set binary_path "./target/debug/testcase-manager"
}

# Verify binary exists
if {![file exists $binary_path]} {
    puts "ERROR: Binary not found at $binary_path"
    exit 1
}

# Setup test environment
set test_dir "test_e2e_[clock seconds]"
set output_file "$test_dir/output_test.yaml"

puts "\n=========================================="
puts "E2E Integration Test for testcase-manager"
puts "=========================================="
puts "Test directory: $test_dir"
puts "Output file: $output_file"
puts "Binary: $binary_path\n"

# Create test directory
file mkdir $test_dir

# Initialize git repository in test directory
exec git init $test_dir
exec git -C $test_dir config user.name "Test User"
exec git -C $test_dir config user.email "test@example.com"

# Set git environment variables
set env(GIT_AUTHOR_NAME) "Test User"
set env(GIT_AUTHOR_EMAIL) "test@example.com"
set env(GIT_COMMITTER_NAME) "Test User"
set env(GIT_COMMITTER_EMAIL) "test@example.com"

# Start the testcase-manager complete workflow
puts "==> Starting testcase-manager complete workflow..."
spawn $binary_path complete -o $output_file

expect {
    timeout {
        puts "\nERROR: Timeout waiting for initial output"
        exec rm -rf $test_dir
        exit 1
    }
    "Complete Interactive Test Case Workflow" {
        puts "✓ Workflow started"
    }
}

# === METADATA SECTION ===
puts "\n==> Entering metadata..."

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for Requirement prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Requirement:" { 
        send "SGP.22_v3.0\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for Item prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Item:" { 
        send "4\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for TC prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "TC:" { 
        send "2\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for ID prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "ID:" { 
        send "test_e2e_001\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for Description prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Description:" { 
        send "E2E integration test case\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for validation"
        exec rm -rf $test_dir
        exit 1 
    }
    "Metadata is valid" {
        puts "✓ Metadata validated"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for commit prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Commit metadata to git?" { 
        send "y\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for commit confirmation"
        exec rm -rf $test_dir
        exit 1 
    }
    -re "Committed.*metadata" {
        puts "✓ Metadata committed to git"
    }
}

# === GENERAL INITIAL CONDITIONS SECTION ===
puts "\n==> Handling general initial conditions..."

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for general IC prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Add general initial conditions?" { 
        send "n\r"
        puts "✓ Skipped general initial conditions"
    }
}

# === INITIAL CONDITIONS SECTION ===
puts "\n==> Adding initial conditions..."

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for initial conditions prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Add initial conditions?" { 
        send "y\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for device name"
        exec rm -rf $test_dir
        exit 1 
    }
    "Device name" { 
        send "eUICC\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for condition #1"
        exec rm -rf $test_dir
        exit 1 
    }
    "Condition #1:" { 
        send "Device in test mode\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for condition #2"
        exec rm -rf $test_dir
        exit 1 
    }
    "Condition #2:" { 
        send "Profile storage available\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for condition #3"
        exec rm -rf $test_dir
        exit 1 
    }
    "Condition #3:" { 
        send "\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for IC validation"
        exec rm -rf $test_dir
        exit 1 
    }
    "Valid structure" {
        puts "✓ Initial conditions validated"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for IC commit prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Commit initial conditions to git?" { 
        send "y\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for IC commit confirmation"
        exec rm -rf $test_dir
        exit 1 
    }
    -re "Committed.*initial conditions" {
        puts "✓ Initial conditions committed to git"
    }
}

# === TEST SEQUENCE SECTION ===
puts "\n==> Adding test sequence..."

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for sequence ID"
        exec rm -rf $test_dir
        exit 1 
    }
    "Sequence ID:" {
        puts "✓ Starting sequence creation"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for fuzzy search prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Use fuzzy search" { 
        send "n\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for sequence name"
        exec rm -rf $test_dir
        exit 1 
    }
    "Sequence name:" { 
        send "Basic Profile Installation\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for editor prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Edit description in editor?" { 
        send "n\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for description prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Description:" { 
        send "Test basic profile installation flow\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for sequence IC prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Add sequence-specific initial conditions?" { 
        send "n\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for sequence validation"
        exec rm -rf $test_dir
        exit 1 
    }
    "Test sequence validated and added" {
        puts "✓ Test sequence validated and added"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for sequence commit prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Commit this sequence to git?" { 
        send "y\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for sequence commit"
        exec rm -rf $test_dir
        exit 1 
    }
    -re "Committed.*sequence" {
        puts "✓ Test sequence committed to git"
    }
}

# === ADD STEPS TO SEQUENCE ===
puts "\n==> Adding steps to sequence..."

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for add steps prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Add steps to this sequence now?" { 
        send "y\r"
    }
}

# STEP 1
expect {
    timeout { 
        puts "\nERROR: Timeout waiting for step #1"
        exec rm -rf $test_dir
        exit 1 
    }
    "Add Step" {
        puts "✓ Adding step 1"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for step fuzzy search"
        exec rm -rf $test_dir
        exit 1 
    }
    "Use fuzzy search" { 
        send "n\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for step description"
        exec rm -rf $test_dir
        exit 1 
    }
    "Step description:" { 
        send "Initialize connection to eUICC\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for manual step prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Is this a manual step?" { 
        send "n\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for command"
        exec rm -rf $test_dir
        exit 1 
    }
    "Command:" { 
        send "ssh init\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for success field prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Include 'success' field?" { 
        send "y\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for success value"
        exec rm -rf $test_dir
        exit 1 
    }
    "Success value" { 
        send "y\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for expected result"
        exec rm -rf $test_dir
        exit 1 
    }
    "Expected result:" { 
        send "SW=9000\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for expected output"
        exec rm -rf $test_dir
        exit 1 
    }
    "Expected output:" { 
        send "Connection established\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for step validation"
        exec rm -rf $test_dir
        exit 1 
    }
    "Step validated and added" {
        puts "✓ Step 1 validated and added"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for step commit prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Commit this step to git?" { 
        send "y\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for step commit"
        exec rm -rf $test_dir
        exit 1 
    }
    -re "Committed.*step" {
        puts "✓ Step 1 committed to git"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for another step prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Add another step to this sequence?" { 
        send "n\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for another sequence prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Add another test sequence?" { 
        send "n\r"
    }
}

# === FINAL SAVE AND COMMIT ===
puts "\n==> Saving and committing final test case..."

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for final save"
        exec rm -rf $test_dir
        exit 1 
    }
    "Complete test case saved to:" {
        puts "✓ Test case saved to file"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for final commit prompt"
        exec rm -rf $test_dir
        exit 1 
    }
    "Commit final complete test case?" { 
        send "y\r"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for final commit"
        exec rm -rf $test_dir
        exit 1 
    }
    "Committed to git" {
        puts "✓ Final test case committed to git"
    }
}

expect {
    timeout { 
        puts "\nERROR: Timeout waiting for completion"
        exec rm -rf $test_dir
        exit 1 
    }
    "Test Case Workflow Completed!" {
        puts "✓ Workflow completed successfully"
    }
}

# Wait for process to complete
expect eof
catch wait result
set exit_status [lindex $result 3]

if {$exit_status != 0} {
    puts "\nERROR: Process exited with status $exit_status"
    exec rm -rf $test_dir
    exit 1
}

puts "\n=========================================="
puts "VALIDATION PHASE"
puts "=========================================="

# === VALIDATE OUTPUT FILE ===
puts "\n==> Validating output YAML file..."

if {![file exists $output_file]} {
    puts "ERROR: Output file not created: $output_file"
    exec rm -rf $test_dir
    exit 1
}
puts "✓ Output file exists"

# Read and parse YAML content
set fp [open $output_file r]
set yaml_content [read $fp]
close $fp

# Validate YAML structure contains required fields
set required_fields {requirement item tc id description initial_conditions test_sequences}
foreach field $required_fields {
    if {![string match "*${field}:*" $yaml_content]} {
        puts "ERROR: Missing required field: $field"
        exec rm -rf $test_dir
        exit 1
    }
}
puts "✓ All required fields present in YAML"

# Validate metadata values
if {![string match "*requirement: SGP.22_v3.0*" $yaml_content]} {
    puts "ERROR: Incorrect requirement value"
    exec rm -rf $test_dir
    exit 1
}
puts "✓ Metadata values correct"

# Validate test sequence structure
if {![string match "*test_sequences:*" $yaml_content]} {
    puts "ERROR: Test sequences not found"
    exec rm -rf $test_dir
    exit 1
}
puts "✓ Test sequences section present"

# Validate steps are present
if {![string match "*steps:*" $yaml_content]} {
    puts "ERROR: Steps not found in test sequence"
    exec rm -rf $test_dir
    exit 1
}
puts "✓ Steps section present"

# Validate specific content
if {![string match "*Basic Profile Installation*" $yaml_content]} {
    puts "ERROR: Test sequence name not found"
    exec rm -rf $test_dir
    exit 1
}
puts "✓ Test sequence name correct"

if {![string match "*Initialize connection to eUICC*" $yaml_content]} {
    puts "ERROR: Step 1 description not found"
    exec rm -rf $test_dir
    exit 1
}
puts "✓ Step descriptions present"

if {![string match "*expected:*" $yaml_content]} {
    puts "ERROR: Expected field not found in steps"
    exec rm -rf $test_dir
    exit 1
}
puts "✓ Expected fields present in steps"

# === VALIDATE GIT COMMITS ===
puts "\n==> Validating git commits..."

# Check git log
set git_log [exec git -C $test_dir log --oneline]
set commit_count [llength [split $git_log "\n"]]

if {$commit_count < 3} {
    puts "ERROR: Expected at least 3 commits, found $commit_count"
    puts "Git log:"
    puts $git_log
    exec rm -rf $test_dir
    exit 1
}
puts "✓ Found $commit_count commits"

# Validate specific commit messages exist
if {[string match "*metadata*" $git_log]} {
    puts "✓ Metadata commit found"
}

if {[string match "*initial conditions*" $git_log]} {
    puts "✓ Initial conditions commit found"
}

if {[string match "*sequence*" $git_log]} {
    puts "✓ Sequence commit found"
}

# === CLEANUP ===
puts "\n==> Cleaning up test environment..."
exec rm -rf $test_dir
puts "✓ Test directory removed"

puts "\n=========================================="
puts "ALL TESTS PASSED ✓"
puts "=========================================="
puts ""

exit 0
