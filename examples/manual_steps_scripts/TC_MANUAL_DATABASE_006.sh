#!/bin/bash
set -euo pipefail

# Test Case: TC_MANUAL_DATABASE_006
# Description: Test case for database verification with manual SQL query validation

JSON_LOG="TC_MANUAL_DATABASE_006_execution_log.json"
TIMESTAMP=$(date +"%Y-%m-%dT%H:%M:%S")

# Trap to ensure JSON file is closed properly on exit
cleanup() {
    if [ -f "$JSON_LOG" ]; then
        # Check if JSON_LOG ends with '[' or ','
        LAST_CHAR=$(tail -c 2 "$JSON_LOG" | head -c 1)
        if [ "$LAST_CHAR" != "]" ]; then
            echo '' >> "$JSON_LOG"
            echo ']' >> "$JSON_LOG"
        fi
        # Validate JSON
        if command -v jq >/dev/null 2>&1; then
            if ! jq empty "$JSON_LOG" >/dev/null 2>&1; then
                echo "500 - Internal Script Error: Generated JSON is not valid" >&2
                exit 1
            fi
        fi
    fi
}
trap cleanup EXIT

echo '[' > "$JSON_LOG"
FIRST_ENTRY=true

# General Initial Conditions
# system: Database client tools are installed
# database: Database server is running
# database: Test database exists

# Initial Conditions
# database: Test data is loaded
# credentials: Database credentials are available

# Test Sequence 1: Database Query and Data Verification
# This test sequence verifies database connectivity, executes
# queries, and manually validates complex data relationships.
# 
# Sequence Initial Conditions
# database: Database is ready for testing

# Step 1: Verify database server is listening
LOG_FILE="TC_MANUAL_DATABASE_006_sequence-1_step-1.actual.log"
COMMAND_OUTPUT=""
set +e
COMMAND_OUTPUT=$({ nc -zv localhost 5432 2>&1 | grep -i 'succeeded\|open' || echo "Database port check"; } 2>&1 | tee "$LOG_FILE")
EXIT_CODE=$?
set -e

# Verification result expression: [[ $EXIT_CODE -eq 0 ]]
# Verification output expression (from variable): true
VERIFICATION_RESULT_PASS=false
VERIFICATION_OUTPUT_PASS=false

RESULT_EXPR="[[ \$EXIT_CODE -eq 0 ]]"

OUTPUT_EXPR="true"

if eval "$RESULT_EXPR"; then
    VERIFICATION_RESULT_PASS=true
fi

if eval "$OUTPUT_EXPR"; then
    VERIFICATION_OUTPUT_PASS=true
fi

if [ "$VERIFICATION_RESULT_PASS" = true ] && [ "$VERIFICATION_OUTPUT_PASS" = true ]; then
    echo "[PASS] Step 1: Verify database server is listening"
else
    echo "[FAIL] Step 1: Verify database server is listening"
    echo "  Command: nc -zv localhost 5432 2>&1 | grep -i 'succeeded\|open' || echo \"Database port check\""
    echo "  Exit code: $EXIT_CODE"
    echo "  Output: $COMMAND_OUTPUT"
    echo "  Result verification: $VERIFICATION_RESULT_PASS"
    echo "  Output verification: $VERIFICATION_OUTPUT_PASS"
    exit 1
fi

# Escape output for JSON (BSD/GNU compatible)
# Use Python for reliable JSON escaping if available, otherwise use sed/perl/awk
if command -v python3 >/dev/null 2>&1; then
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | python3 -c 'import sys, json; s=sys.stdin.read(); print(json.dumps(s)[1:-1], end="")')
elif command -v python >/dev/null 2>&1; then
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | python -c 'import sys, json; s=sys.stdin.read(); print json.dumps(s)[1:-1]')
elif command -v perl >/dev/null 2>&1; then
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | perl -pe 's/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g' | tr -d '\n')
else
    # Fallback: escape backslashes, quotes, tabs, and convert newlines to \n
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g' | awk '{printf "%s%s", (NR>1?"\\n":""), $0}')
fi

if [ "$FIRST_ENTRY" = false ]; then
    echo ',' >> "$JSON_LOG"
fi
FIRST_ENTRY=false

# Write JSON entry
{
    echo '  {'
    echo '    "test_sequence": 1,'
    echo '    "step": 1,'
    echo '    "command": "nc -zv localhost 5432 2>&1 | grep -i \"succeeded\\|open\" || echo \"Database port check\"",'
    echo "    \"exit_code\": $EXIT_CODE,"
    echo "    \"output\": \"$OUTPUT_ESCAPED\","
    echo "    \"timestamp\": \"$TIMESTAMP\""
    echo '  }'
} >> "$JSON_LOG"

# Step 2: Check database connection
LOG_FILE="TC_MANUAL_DATABASE_006_sequence-1_step-2.actual.log"
COMMAND_OUTPUT=""
set +e
COMMAND_OUTPUT=$({ echo "SELECT 1" | psql -h localhost -U testuser testdb 2>/dev/null || echo "Database connection test"; } 2>&1 | tee "$LOG_FILE")
EXIT_CODE=$?
set -e

# Verification result expression: [[ $EXIT_CODE -eq 0 ]]
# Verification output expression (from variable): true
VERIFICATION_RESULT_PASS=false
VERIFICATION_OUTPUT_PASS=false

RESULT_EXPR="[[ \$EXIT_CODE -eq 0 ]]"

OUTPUT_EXPR="true"

if eval "$RESULT_EXPR"; then
    VERIFICATION_RESULT_PASS=true
fi

if eval "$OUTPUT_EXPR"; then
    VERIFICATION_OUTPUT_PASS=true
fi

if [ "$VERIFICATION_RESULT_PASS" = true ] && [ "$VERIFICATION_OUTPUT_PASS" = true ]; then
    echo "[PASS] Step 2: Check database connection"
else
    echo "[FAIL] Step 2: Check database connection"
    echo "  Command: echo \"SELECT 1\" | psql -h localhost -U testuser testdb 2>/dev/null || echo \"Database connection test\""
    echo "  Exit code: $EXIT_CODE"
    echo "  Output: $COMMAND_OUTPUT"
    echo "  Result verification: $VERIFICATION_RESULT_PASS"
    echo "  Output verification: $VERIFICATION_OUTPUT_PASS"
    exit 1
fi

# Escape output for JSON (BSD/GNU compatible)
# Use Python for reliable JSON escaping if available, otherwise use sed/perl/awk
if command -v python3 >/dev/null 2>&1; then
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | python3 -c 'import sys, json; s=sys.stdin.read(); print(json.dumps(s)[1:-1], end="")')
elif command -v python >/dev/null 2>&1; then
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | python -c 'import sys, json; s=sys.stdin.read(); print json.dumps(s)[1:-1]')
elif command -v perl >/dev/null 2>&1; then
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | perl -pe 's/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g' | tr -d '\n')
else
    # Fallback: escape backslashes, quotes, tabs, and convert newlines to \n
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g' | awk '{printf "%s%s", (NR>1?"\\n":""), $0}')
fi

if [ "$FIRST_ENTRY" = false ]; then
    echo ',' >> "$JSON_LOG"
fi
FIRST_ENTRY=false

# Write JSON entry
{
    echo '  {'
    echo '    "test_sequence": 1,'
    echo '    "step": 2,'
    echo '    "command": "echo \"SELECT 1\" | psql -h localhost -U testuser testdb 2>/dev/null || echo \"Database connection test\"",'
    echo "    \"exit_code\": $EXIT_CODE,"
    echo "    \"output\": \"$OUTPUT_ESCAPED\","
    echo "    \"timestamp\": \"$TIMESTAMP\""
    echo '  }'
} >> "$JSON_LOG"

# Step 3: Manually execute query to check user table row count
echo "Step 3: Manually execute query to check user table row count"
echo "Command: SELECT COUNT(*) FROM users WHERE status='active'"
echo "INFO: This is a manual step. You must perform this action manually."
if [[ "${DEBIAN_FRONTEND}" != 'noninteractive' && -t 0 ]]; then
    read -p "Press ENTER to continue..."
else
    echo "Non-interactive mode detected, skipping manual step confirmation."
fi

# Step 4: Manually verify data integrity across related tables
echo "Step 4: Manually verify data integrity across related tables"
echo "Command: SELECT u.name, o.order_id FROM users u JOIN orders o ON u.id=o.user_id LIMIT 5"
echo "INFO: This is a manual step. You must perform this action manually."
if [[ "${DEBIAN_FRONTEND}" != 'noninteractive' && -t 0 ]]; then
    read -p "Press ENTER to continue..."
else
    echo "Non-interactive mode detected, skipping manual step confirmation."
fi

# Step 5: Check database transaction log
LOG_FILE="TC_MANUAL_DATABASE_006_sequence-1_step-5.actual.log"
COMMAND_OUTPUT=""
set +e
COMMAND_OUTPUT=$({ echo "Transaction log check completed" && date +%Y-%m-%d; } 2>&1 | tee "$LOG_FILE")
EXIT_CODE=$?
set -e

# Verification result expression: [[ $EXIT_CODE -eq 0 ]]
# Verification output expression (from file): grep -q 'Transaction log check completed' "$LOG_FILE"
VERIFICATION_RESULT_PASS=false
VERIFICATION_OUTPUT_PASS=false

RESULT_EXPR="[[ \$EXIT_CODE -eq 0 ]]"

OUTPUT_EXPR="grep -q 'Transaction log check completed' \"\$LOG_FILE\""

if eval "$RESULT_EXPR"; then
    VERIFICATION_RESULT_PASS=true
fi

if eval "$OUTPUT_EXPR"; then
    VERIFICATION_OUTPUT_PASS=true
fi

if [ "$VERIFICATION_RESULT_PASS" = true ] && [ "$VERIFICATION_OUTPUT_PASS" = true ]; then
    echo "[PASS] Step 5: Check database transaction log"
else
    echo "[FAIL] Step 5: Check database transaction log"
    echo "  Command: echo \"Transaction log check completed\" && date +%Y-%m-%d"
    echo "  Exit code: $EXIT_CODE"
    echo "  Output: $COMMAND_OUTPUT"
    echo "  Result verification: $VERIFICATION_RESULT_PASS"
    echo "  Output verification: $VERIFICATION_OUTPUT_PASS"
    exit 1
fi

# Escape output for JSON (BSD/GNU compatible)
# Use Python for reliable JSON escaping if available, otherwise use sed/perl/awk
if command -v python3 >/dev/null 2>&1; then
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | python3 -c 'import sys, json; s=sys.stdin.read(); print(json.dumps(s)[1:-1], end="")')
elif command -v python >/dev/null 2>&1; then
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | python -c 'import sys, json; s=sys.stdin.read(); print json.dumps(s)[1:-1]')
elif command -v perl >/dev/null 2>&1; then
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | perl -pe 's/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g' | tr -d '\n')
else
    # Fallback: escape backslashes, quotes, tabs, and convert newlines to \n
    OUTPUT_ESCAPED=$(printf '%s' "$COMMAND_OUTPUT" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g' | awk '{printf "%s%s", (NR>1?"\\n":""), $0}')
fi

if [ "$FIRST_ENTRY" = false ]; then
    echo ',' >> "$JSON_LOG"
fi
FIRST_ENTRY=false

# Write JSON entry
{
    echo '  {'
    echo '    "test_sequence": 1,'
    echo '    "step": 5,'
    echo '    "command": "echo \"Transaction log check completed\" && date +%Y-%m-%d",'
    echo "    \"exit_code\": $EXIT_CODE,"
    echo "    \"output\": \"$OUTPUT_ESCAPED\","
    echo "    \"timestamp\": \"$TIMESTAMP\""
    echo '  }'
} >> "$JSON_LOG"

echo ']' >> "$JSON_LOG"

# Validate JSON against schema
if command -v jq >/dev/null 2>&1; then
    if ! jq empty "$JSON_LOG" >/dev/null 2>&1; then
        echo "500 - Internal Script Error: Generated JSON is not valid"
        exit 1
    fi
fi

echo "All test sequences completed successfully"
exit 0
